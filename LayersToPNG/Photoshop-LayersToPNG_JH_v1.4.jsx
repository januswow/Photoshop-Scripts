// Spine Layers to png// This script exports photoshop layers as individual PNGs. It also// writes a JSON file that can be imported into Spine where the images// will be displayed in the same positions and draw order.// Mod by JanusHuang// (e-mail:januswow@gmail.com)//// v1.0.0// - Allow defining custom scale and rotation to specified layer by adding suffixes to the layer name, and will apply on exported images and JSON data.// v1.1.0// - Prevent getting a crash from incorrect suffixes.// - Now export images through 'Save For Web'.// - Calculate transform data by layer bounds.// - Allow corp pixels out of canvas.// - Fixed incorrect position after layer rotated.// - Setup template attachment correctly after 'Import Data' in Spine.// v1.2.0// - Allow merge group automatically.// - Allow trim layer or not.// - Can now ignore layers with the gray color label (Photoshop CC Only!!).// - Can now ignore layers start with an underscore ("_").// v1.3.0// - Allow group as a slot (need to add suffix " #SLOT"), and each layer inside as attachment.// - Fixed wrong slot order while has skins.// - JSON data format now is the same as exported from Spine.// v1.3.1// - Fixed information of done dialog.// v1.4.0// - Added "Use '_ROOT' layer as origin", will set Spine origin position as the center of layer's bound.// - Fixed incorrect JSON data when there is only one layer in the slot.// - Fixed 'use ruler origin as 0,0'.// - JSON data now include layer's blend mode.// - JSON data now include layer's opacity.// - Can now set resample method for resizing.//// ## How to define custom scale and rotation// Gives you more ability to optimize texture resolution.// 		You are able to set export scale and rotation values for a specific layer in Photoshop and keep the size and rotation of attachments after importing to Spine, just the same as you see in Photoshop.// // Define scale and rotation by adding suffixes to the layer name.// Define scale by adding suffix ' #s' to the layer name.// Define rotation by adding suffix ' #r' to the layer name.// // ex.// 'thisislayername #s0.5' (scale = 50%)// 'thisislayername #s0.8 #r-12' (scale = 80%, rotation = -12 degree)// Note: Suffix is case-sensitive.// // ## How to use group as slot// Adding suffix ' #SLOT' to the group name will export group as a slot, and each layer in the group will export as an attachment(PNG).// Note: Suffix is case-sensitive.//// ## How to use '_ROOT' as origin// Create a layer named '_ROOT', and draw a dot at the origin position. To prevent exporting '_ROOT' layer, you can hide the layer or enable 'Ignore starts with an underscore'.// Note: Layer name is case-sensitive.//// Original Version : https://gist.github.com/NathanSweet/c8e2f6e1d79dedd56e8c// Setting defaults.var writePngs = true;var writeTemplate = false;var writeJson = true;var ignoreHiddenLayers = true;var pngScale = 1;var groupsAsSkins = false;var useRulerOrigin = false;var imagesDir = "./images/";var projectDir = "";var padding = 1;// Setting defaults. JH Version.var corpToCanvas = false;var mergeGroups = true;var allowTrimLayers = true;var ignoreGrayLabelLayers = false;var ignoreStartsWithUnderscoreLayers = true;var useRootLayer = false;var resample = 1;var resampleObject;var resampleMethods = { 	"Bicubic" : ResampleMethod.BICUBIC, 	"Bicubic Sharper" : ResampleMethod.BICUBICSHARPER,	"Bicubic Smoother" : ResampleMethod.BICUBICSMOOTHER, 	"Bilinear" : ResampleMethod.BILINEAR, 	"Nearest Neighbor" : ResampleMethod.NEARESTNEIGHBOR}// JH Version Variablesvar JHVersion = "1.4.0"var patternRotate = " #r";var patternScale = " #s";var patternNoSkin = "-NOSKIN";var patternAsSlot = " #SLOT";var rootLayerName = "_ROOT";// Minimum width/height pixels of output imagevar customScaleMin = 4;var docWidth;var docHeight;var startTime;var endTime;var autoCloseDoc = true;var mergeDoc;// IDs for saving settings.const settingsID = stringIDToTypeID("settings");const writePngsID = stringIDToTypeID("writePngs");const writeTemplateID = stringIDToTypeID("writeTemplate");const writeJsonID = stringIDToTypeID("writeJson");const ignoreHiddenLayersID = stringIDToTypeID("ignoreHiddenLayers");const groupsAsSkinsID = stringIDToTypeID("groupsAsSkins");const useRulerOriginID = stringIDToTypeID("useRulerOrigin");const corpToCanvasID = stringIDToTypeID("corpToCanvas");const mergeGroupsID = stringIDToTypeID("mergeGroups");const allowTrimLayersID = stringIDToTypeID("allowTrimLayers");const ignoreGrayLabelLayersID = stringIDToTypeID("ignoreGrayLabelLayers");const ignoreStartsWithUnderscoreLayersID = stringIDToTypeID("ignoreStartsWithUnderscoreLayers");const useRootLayerID = stringIDToTypeID("useRootLayer");const pngScaleID = stringIDToTypeID("pngScale");const imagesDirID = stringIDToTypeID("imagesDir");const projectDirID = stringIDToTypeID("projectDir");const paddingID = stringIDToTypeID("padding");const resampleID = stringIDToTypeID("resample");// For debugstartTime = new Date().getTime();var originalDoc;try {	originalDoc = app.activeDocument;} catch (ignored) {}var settings, progress;loadSettings();showDialog();// Execute while OK button pressed.function run () {	// Output dirs.	var absProjectDir = absolutePath(projectDir);	new Folder(absProjectDir).create();	var absImagesDir = absolutePath(imagesDir);	var imagesFolder = new Folder(absImagesDir);	imagesFolder.create();	var relImagesDir = imagesFolder.getRelativeURI(absProjectDir);	relImagesDir = relImagesDir == "." ? "" : (relImagesDir + "/");	// Get ruler origin.	var xOffSet = 0, yOffSet = 0;	if (useRulerOrigin) {		var ref = new ActionReference();		ref.putEnumerated(charIDToTypeID("Dcmn"), charIDToTypeID("Ordn"), charIDToTypeID("Trgt"));		var desc = executeActionGet(ref);		xOffSet = desc.getInteger(stringIDToTypeID("rulerOriginH")) >> 16;		yOffSet = desc.getInteger(stringIDToTypeID("rulerOriginV")) >> 16;	}	// Get root position from root layer	if (useRootLayer) {		var rootLayer = app.activeDocument.layers.getByName(rootLayerName);		if (rootLayer) {			var rootLayerCenter = getBoundsCenter(rootLayer);			xOffSet = rootLayerCenter[0];			yOffSet = rootLayerCenter[1];		}	}    // Save for web options 	var outputExtension = ".png";    var sfwOptions;    sfwOptions = new ExportOptionsSaveForWeb();    sfwOptions.format = SaveDocumentType.PNG;    // Save to PNG24    sfwOptions.PNG8 = false;	activeDocument.duplicate();	// Output template image.	if (writeTemplate) {		if (pngScale != 1) {			scaleImage();			storeHistory();		}		var file = new File(absImagesDir + "template" + outputExtension);		if (file.exists) file.remove();		activeDocument.exportDocument(file, ExportType.SAVEFORWEB, sfwOptions);		if (pngScale != 1) restoreHistory();	}	// Merge all groups, except slot groups and skin group while groupsAsSkins.	if (mergeGroups) {		mergeDoc = activeDocument;		var groups = [];		collectGroups(activeDocument, groups);		mergeEachGroups(groups);		activeDocument.duplicate();	}	if (!writeJson && !writePngs) {		activeDocument.close(SaveOptions.DONOTSAVECHANGES);		return;	}		// Rasterize all layers.	try {		executeAction(stringIDToTypeID( "rasterizeAll" ), undefined, DialogModes.NO);	} catch (ignored) {}	// Collect and hide layers.	var layers = [];	var layersOpacity = {};	var layersBlend = {};	collectLayers(activeDocument, layers, layersOpacity, layersBlend);	var layersCount = layers.length;	storeHistory();		// Store the slot names and layers for each skin.	var slots = {};	var skins = { "default": [] };	var skinsOnlySlots = { "default": [] };	var lastSlotName = "";	for (var i = layersCount - 1; i >= 0; i--) {		var layer = layers[i];		var currentSlotName = "";		// Use groups as skin names.		var potentialSkinName;		if (isGroupAsSlot(layer.parent)) {			// Current layer is in slot group.			potentialSkinName = trim(layer.parent.parent.name);			currentSlotName = layerName(layer.parent)		} else {			// Current layer is in skin group.			potentialSkinName = trim(layer.parent.name);			currentSlotName = layerName(layer)		}		var layerGroupSkin = potentialSkinName.indexOf(patternNoSkin) == -1;		var skinName = (groupsAsSkins && layer.parent.typename == "LayerSet" && layerGroupSkin) ? potentialSkinName : "default";		// Store skins' layers		var skinLayers = skins[skinName];		if (!skinLayers) skins[skinName] = skinLayers = [];		skinLayers[skinLayers.length] = layer;		// Store skins' slots		if (lastSlotName != currentSlotName) {			var skinSlots = skinsOnlySlots[skinName];			if (!skinSlots) skinsOnlySlots[skinName] = skinSlots = [];			skinSlots[skinSlots.length] = currentSlotName;		}		slots[currentSlotName] = true;		lastSlotName = currentSlotName;	}	// Resort slots order to fix the orders while groupsAsSkins.	if (groupsAsSkins) slots = resortSlotsOrder(slots, skinsOnlySlots);		// Output skeleton and bones --------------------------------------------------	var json = '{\n"skeleton": { "images": "' + relImagesDir + '" },';	json += '\n"bones": [\n\t{ "name": "root" }\n],\n';	// Output slots data. --------------------------------------------------	json += '"slots": [\n';	var slotsCount = countAssocArray(slots);	var slotIndex = 0;	// Output template slot	if (writeTemplate) {		json += '\t{"name": "' + "template" + '", "bone": "root", "attachment": "' + "template" + '" }';		json += slotsCount > 0 ? ",\n" : "\n";	}	// Output slots	for (var slotName in slots) {		if (!slots.hasOwnProperty(slotName)) continue;		// Use image prefix if slot's attachment is in the default skin.		var attachmentName = slotName;		var defaultSkinLayers = skins["default"];				for (var i = defaultSkinLayers.length - 1; i >= 0; i--) {			if (layerName(defaultSkinLayers[i]) == slotName) {				attachmentName = slotName;				break;			}		}		// Write slot name and attachment name		json += '\t{ "name": "' + slotName + '", "bone": "root", "attachment": "' + attachmentName + '"';		// Write opacity		if (layersOpacity[slotName] != null) {			json += ', "color": "ffffff' + Math.round(layersOpacity[slotName]).toString(16) + '"';		}		// Write blendmode		if (layersBlend[slotName] != null) {			json += ', "blend": "' + layersBlend[slotName] + '"';		}		json += ' }';		slotIndex++;		json += slotIndex < slotsCount ? ",\n" : "\n";	}	// Output skins. --------------------------------------------------	json += '],\n"skins": {\n';	var skinsCount = countAssocArray(skins);	var skinIndex = 0;	docWidth = activeDocument.width.as("px");	docHeight = activeDocument.height.as("px");	// For debug	var imagesExportedCount = 0;	var imagesExportedCountTotal = 0;	var doneString = "Done!\nSkins ----------";		for (var skinName in skins) {		if (!skins.hasOwnProperty(skinName)) continue;		var skinLayers = skins[skinName];		var skinLayersCount = skinLayers.length;		var skinLayerIndex = 0;		json += '\t"' + skinName + '": {';		if (skinLayersCount > 0) json += "\n";		// Output Template		if (writeTemplate) {			json += '\t\t"' + "template" + '": { "' + "template" + '": {'			if (useRulerOrigin) {				json += '"x": ' + docWidth / 2 + ',"y": ' + docHeight / 2 * -1;			} else {				json += '"x": ' + docWidth / 2 + ',"y": ' + docHeight / 2;			}						json += ',"width": ' + docWidth + ',"height": ' + docHeight + '}}';			json += skinLayersCount > 0 ? ",\n" : "\n";		}		var layersInSlotIndex = 0;		for (var i = skinLayersCount - 1; i >= 0; i--) {			var layer = skinLayers[i];			var sourceLayerName = srcLayerName(layer);			var slotName;			var currentLayerName = layerName(layer);			if (isGroupAsSlot(layer.parent)) {				// Target layer's parent is group as slot				slotName = layerName(layer.parent);			} else {				slotName = currentLayerName;			}						var placeholderName, attachmentName;			if (skinName == "default") {				placeholderName = currentLayerName;				attachmentName = currentLayerName;			} else {				placeholderName = currentLayerName;				attachmentName = skinName + "/" + currentLayerName;			}			layer.visible = true;			// Get data from bounds			var x = docWidth * 0.5;			var y = docHeight * 0.5;			var boundsCenter = getBoundsCenter(layer);			if (allowTrimLayers) {				x = boundsCenter[0];				y = boundsCenter[1];			}			var customRotate = 0;			var customScale = 1;			// Get custom scale and rotation from layer name			if (hasCustomParameters(sourceLayerName)) {				customRotate = getRotate(sourceLayerName);				customScale = getScale(sourceLayerName);				// Prevent resolution of output image too small				if (customScale != 1) customScale = checkMinimumCustomScale(layer, customScale);			}						// Rotate image			if (customRotate != 0) {				layer.rotate(customRotate, AnchorPosition.MIDDLECENTER);				var rotatedCenter = getBoundsCenter(layer);				var fixedCenter = fixRotatedOffset(rotatedCenter, boundsCenter, customRotate);				x = fixedCenter[0];				y = fixedCenter[1];			}						// Corp to canvas and trim layer			if (!corpToCanvas || customRotate != 0) extendCanvas(layer);			if (!layer.isBackgroundLayer && allowTrimLayers) activeDocument.trim(TrimType.TRANSPARENT, false, false, true, true);			if (corpToCanvas && customRotate == 0) {				x = getCorpBoundsCenter(layer)[0];				y = getCorpBoundsCenter(layer)[1];			}			if (!layer.isBackgroundLayer && allowTrimLayers) activeDocument.trim(TrimType.TRANSPARENT, true, true, false, false);			// Scale image			if (pngScale != 1 || customScale != 1) {				scaleImage(customScale);			}			// Padding			if (padding > 0) {				var canvasWidth = activeDocument.width.as("px") + padding * 2;				var canvasHeight = activeDocument.height.as("px") + padding * 2;				activeDocument.resizeCanvas(canvasWidth, canvasHeight, AnchorPosition.MIDDLECENTER);			}			// Save image			if (writePngs) {				if (skinName != "default") new Folder(absImagesDir + skinName).create();				activeDocument.exportDocument(new File(absImagesDir + attachmentName + outputExtension), ExportType.SAVEFORWEB, sfwOptions);				imagesExportedCount += 1;			}			restoreHistory();			layer.visible = false;			// Shift root position			y = docHeight - y;			if (useRulerOrigin || useRootLayer) {				x -= xOffSet;				y -= (docHeight - yOffSet);			}			var outScale = mathRound(1 / customScale, 2);			// Write JSON			// example :			// 		"emo_brows": {			// 			"emo_brows-hit": { "name": "skin1/emo_brows-hit", "x": 418,"y": 713,"width": 100,"height": 60 },			//			"emo_brows-win": { "name": "skin1/emo_brows-win", "x": 410,"y": 710,"width": 103,"height": 63 }			// 		},			if (layersInSlotIndex == 0) {				json += '\t\t"' + slotName + '": {';			}						if (attachmentName == placeholderName) {				json += '\n\t\t\t"' + placeholderName + '": {';			} else {				json += '\n\t\t\t"' + placeholderName + '": { "name": "' + attachmentName + '", ';			}						// Write position			json += '"x": ' + mathRound(x, 1) + ',"y": ' + mathRound(y, 1);			// Write custom scale			if (customScale != 1) json += ',"scaleX": ' + outScale + ',"scaleY": ' + outScale;			// Write custom rotate			if (customRotate != 0) json += ',"rotation": ' + customRotate;			// Write size			json += ',"width": ' + Math.round(canvasWidth) + ',"height": ' + Math.round(canvasHeight);			// Write end of code			skinLayerIndex++;			if (isGroupAsSlot(layer.parent) && layer.parent.layers && layersInSlotIndex < getVisibleSiblingLayersCount(layer, skinLayers) - 1)			{				// Run next layer in slot				json += ' },'				layersInSlotIndex++;			} else {				// End the slot				json += ' }\n\t\t}';				layersInSlotIndex = 0;				json += skinLayerIndex < skinLayersCount ? ",\n" : "\n";			}		}		if (skinLayersCount > 0) json += "\t";		json += "\}";		// For debug		imagesExportedCountTotal += imagesExportedCount;		doneString += "\n\t" + skinName + ": " + imagesExportedCount;		imagesExportedCount = 0;		skinIndex++;		json += skinIndex < skinsCount ? ",\n" : "\n";	}	// Output animations. --------------------------------------------------	json += '},\n"animations":{\n\t"animation": {}\n}\n}';	if (autoCloseDoc) {		if (mergeDoc) mergeDoc.close(SaveOptions.DONOTSAVECHANGES);		activeDocument.close(SaveOptions.DONOTSAVECHANGES);	}	// Output JSON file.	if (writeJson) {		var name = decodeURI(originalDoc.name);		name = name.substring(0, name.indexOf("."));		var file = new File(absProjectDir + name + ".json");		file.remove();		file.open("w", "TEXT");		file.lineFeed = "\n";		file.write(json);		file.close();	}	// For debug	doneString += "\n" + "- Total exported : " + imagesExportedCountTotal;	doneString += "\n\n" + "Resample method : " + resampleObject.toString();	endTime = new Date().getTime();	var elapsedTime = mathRound(( endTime - startTime ) / 1000, 0);	doneString += "\n" + "Elapsed time : " + elapsedTime + "s";	alert(doneString);}// Dialog and settings:function showDialog () {	if (!originalDoc) {		alert("Please open a document before running the LayersToPNG script.");		return;	}	if (!hasFilePath()) {		alert("Please save the document before running the LayersToPNG script.");		return;	}	var dialog = new Window("dialog", "Spine LayersToPNG JH v" + JHVersion + " by JanusHuang");	dialog.alignChildren = "fill";	var checkboxGroup = dialog.add("group");		var group = checkboxGroup.add("group");			group.orientation = "column";			group.alignChildren = "left";			var writePngsCheckbox = group.add("checkbox", undefined, " Write layers as PNGs");			writePngsCheckbox.value = writePngs;			var writeTemplateCheckbox = group.add("checkbox", undefined, " Write a template PNG");			writeTemplateCheckbox.value = writeTemplate;			var writeJsonCheckbox = group.add("checkbox", undefined, " Write Spine JSON");			writeJsonCheckbox.value = writeJson;			var emptyCheckbox = group.add("checkbox", undefined, " Write layer opacity");			emptyCheckbox.value = true;			emptyCheckbox.enabled = false;			var emptyCheckbox = group.add("checkbox", undefined, " Write layer blendmode");			emptyCheckbox.value = true;			emptyCheckbox.enabled = false;			var emptyCheckbox = group.add("checkbox", undefined, " Write custom S/R ( #s/ #r)");			emptyCheckbox.value = true;			emptyCheckbox.enabled = false;			var emptyCheckbox = group.add("checkbox", undefined, " Empty");			emptyCheckbox.visible = false;			emptyCheckbox.enabled = false;			var emptyCheckbox = group.add("checkbox", undefined, " Empty");			emptyCheckbox.visible = false;			emptyCheckbox.enabled = false;		group = checkboxGroup.add("group");			group.orientation = "column";			group.alignChildren = "left";			var ignoreHiddenLayersCheckbox = group.add("checkbox", undefined, " Ignore hidden layers");			ignoreHiddenLayersCheckbox.value = ignoreHiddenLayers;			var ignoreStartsWithUnderscoreLayersCheckbox = group.add("checkbox", undefined, " Ignore starts with an underscroe");			ignoreStartsWithUnderscoreLayersCheckbox.value = ignoreStartsWithUnderscoreLayers;			var ignoreGrayLabelLayersCheckbox = group.add("checkbox", undefined, " Ignore gray label layers (CC Only)");			ignoreGrayLabelLayersCheckbox.value = ignoreGrayLabelLayers;			var allowTrimLayersCheckbox = group.add("checkbox", undefined, " Trim layers");			allowTrimLayersCheckbox.value = allowTrimLayers;			var corpToCanvasCheckbox = group.add("checkbox", undefined, " Corp to canvas");			corpToCanvasCheckbox.value = corpToCanvas;			var groupsAsSkinsCheckbox = group.add("checkbox", undefined, " Use groups as skins");			groupsAsSkinsCheckbox.value = groupsAsSkins;			var emptyCheckbox = group.add("checkbox", undefined, " Allow group as slot ( #SLOT)");			emptyCheckbox.value = true;			emptyCheckbox.enabled = false;			var mergeGroupsCheckbox = group.add("checkbox", undefined, " Merge groups");			mergeGroupsCheckbox.value = mergeGroups;	var originGroup = dialog.add("panel", undefined, "Origin Settings (as 0,0)");		originGroup.orientation = "row";		originGroup.margins = [10,15,10,10];		var useDefaultOriginCheckbox = originGroup.add("radiobutton", undefined, " Default (LB)");		var useRulerOriginCheckbox = originGroup.add("radiobutton", undefined, " Use ruler origin");		useRulerOriginCheckbox.value = useRulerOrigin;		var useRootLayerCheckbox = originGroup.add("radiobutton", undefined, " Use '_ROOT' layer");		useRootLayerCheckbox.value = useRootLayer;		if (useRulerOriginCheckbox.value == false && useRootLayerCheckbox.value == false) useDefaultOriginCheckbox.value = true;	var resampleGroup = dialog.add("group");		group = resampleGroup.add("group");			group.orientation = "column";			group.alignChildren = "right";			group.add("statictext", undefined, "Resample Method:");		group = resampleGroup.add("group");			group.alignment = ["fill", ""];			group.orientation = "column";			group.alignChildren = ["fill", ""];			var resampleDdl = group.add("dropdownlist", undefined, ["Bicubic", "Bicubic Sharper", "Bicubic Smoother", "Bilinear", "Nearest Neighbor"]);			resampleDdl.selection = resample;	var slidersGroup = dialog.add("group");		group = slidersGroup.add("group");			group.orientation = "column";			group.alignChildren = "right";			group.add("statictext", undefined, "PNG scale:");			group.add("statictext", undefined, "Padding:");		group = slidersGroup.add("group");			group.orientation = "column";			var scaleText = group.add("edittext", undefined, pngScale * 100);			scaleText.characters = 4;			var paddingText = group.add("edittext", undefined, padding);			paddingText.characters = 4;		group = slidersGroup.add("group");			group.orientation = "column";			group.add("statictext", undefined, "%");			group.add("statictext", undefined, "px");		group = slidersGroup.add("group");			group.alignment = ["fill", ""];			group.orientation = "column";			group.alignChildren = ["fill", ""];			var scaleSlider = group.add("slider", undefined, pngScale * 100, 1, 100);			var paddingSlider = group.add("slider", undefined, padding, 0, 4);	scaleText.onChanging = function () { scaleSlider.value = scaleText.text; };	scaleSlider.onChanging = function () { scaleText.text = Math.round(scaleSlider.value); };	paddingText.onChanging = function () { paddingSlider.value = paddingText.text; };	paddingSlider.onChanging = function () { paddingText.text = Math.round(paddingSlider.value); };	var outputGroup = dialog.add("panel", undefined, "Output directories");		outputGroup.alignChildren = "fill";		outputGroup.margins = [10,15,10,10];		var textGroup = outputGroup.add("group");			group = textGroup.add("group");				group.orientation = "column";				group.alignChildren = "right";				group.add("statictext", undefined, "Images:");				group.add("statictext", undefined, "JSON:");			group = textGroup.add("group");				group.orientation = "column";				group.alignChildren = "fill";				group.alignment = ["fill", ""];				var imagesDirText = group.add("edittext", undefined, imagesDir);				var projectDirText = group.add("edittext", undefined, projectDir);		outputGroup.add("statictext", undefined, "Begin paths with \"./\" to be relative to the PSD file.").alignment = "center";	var group = dialog.add("group");		// group.alignment = "center";		var runButton = group.add("button", undefined, "OK");		var cancelButton = group.add("button", undefined, "Cancel");		// JH Version Help dialog.		var JHButton = group.add("button", undefined, "!");		var JHHelpString = "Adding suffix...";		JHHelpString += "\n\n◆ You can define scale and rotation by adding suffixes to layer name.";		JHHelpString += "\n∙ Define scale by suffix ' #s'.";		JHHelpString += "\n∙ Define roataion by suffix ' #r'.";		JHHelpString += "\n\n ex. 'thisislayername #s0.5' (scale = 50%)";		JHHelpString += "\n ex. 'thisislayername #s0.8 #r-12' (scale = 80%, rotation = -12 degree)";		JHHelpString += "\n\n◆ You can set group as slot by adding suffix ' #SLOT' to group name, and the layers/groups inside will be attchments.";		JHHelpString += "\n ex. 'thisisgroupname #SLOT'";		JHHelpString += "\n\n* Suffix is case-sensitive.";		JHButton.size = [24,20];		JHButton.onClick = function () {			alert(JHHelpString);		};		cancelButton.onClick = function () {			dialog.close(0);			return;		};	function updateSettings () {		writePngs = writePngsCheckbox.value;		writeTemplate = writeTemplateCheckbox.value;		writeJson = writeJsonCheckbox.value;		ignoreHiddenLayers = ignoreHiddenLayersCheckbox.value;		var scaleValue = parseFloat(scaleText.text);		if (scaleValue > 0 && scaleValue <= 100) pngScale = scaleValue / 100;		groupsAsSkins = groupsAsSkinsCheckbox.value;		useRulerOrigin = useRulerOriginCheckbox.value;		corpToCanvas = corpToCanvasCheckbox.value;		mergeGroups = mergeGroupsCheckbox.value;		allowTrimLayers = allowTrimLayersCheckbox.value;		ignoreGrayLabelLayers = ignoreGrayLabelLayersCheckbox.value;		ignoreStartsWithUnderscoreLayers = ignoreStartsWithUnderscoreLayersCheckbox.value;		useRootLayer = useRootLayerCheckbox.value;		imagesDir = imagesDirText.text;		projectDir = projectDirText.text;		var paddingValue = parseInt(paddingText.text);		if (paddingValue >= 0) padding = paddingValue;		resample = resampleDdl.selection.index;		resampleObject = resampleDdl.selection;	}	dialog.onClose = function() {		updateSettings();		saveSettings();	};		runButton.onClick = function () {		if (scaleText.text <= 0 || scaleText.text > 100) {			alert("PNG scale must be between > 0 and <= 100.");			return;		}		if (paddingText.text < 0) {			alert("Padding must be >= 0.");			return;		}		dialog.close(0);		var rulerUnits = app.preferences.rulerUnits;		app.preferences.rulerUnits = Units.PIXELS;		try {			run();		} catch (e) {			alert("An unexpected error has occurred.\n\nTo debug, run the LayersToPNG script using Adobe ExtendScript "				+ "with \"Debug > Do not break on guarded exceptions\" unchecked.");			debugger;		} finally {			if (activeDocument != originalDoc && autoCloseDoc) {				if (mergeDoc) mergeDoc.close(SaveOptions.DONOTSAVECHANGES);				activeDocument.close(SaveOptions.DONOTSAVECHANGES);			}			app.preferences.rulerUnits = rulerUnits;		}	};	dialog.center();	dialog.show();}function loadSettings () {	try {		settings = app.getCustomOptions(settingsID);	} catch (e) {		saveSettings();	}	if (typeof settings == "undefined") saveSettings();	settings = app.getCustomOptions(settingsID);	if (settings.hasKey(writePngsID)) writePngs = settings.getBoolean(writePngsID);	if (settings.hasKey(writeTemplateID)) writeTemplate = settings.getBoolean(writeTemplateID);	if (settings.hasKey(writeJsonID)) writeJson = settings.getBoolean(writeJsonID);	if (settings.hasKey(ignoreHiddenLayersID)) ignoreHiddenLayers = settings.getBoolean(ignoreHiddenLayersID);	if (settings.hasKey(pngScaleID)) pngScale = settings.getDouble(pngScaleID);	if (settings.hasKey(groupsAsSkinsID)) groupsAsSkins = settings.getBoolean(groupsAsSkinsID);	if (settings.hasKey(useRulerOriginID)) useRulerOrigin = settings.getBoolean(useRulerOriginID);	if (settings.hasKey(corpToCanvasID)) corpToCanvas = settings.getBoolean(corpToCanvasID);	if (settings.hasKey(mergeGroupsID)) mergeGroups = settings.getBoolean(mergeGroupsID);	if (settings.hasKey(allowTrimLayersID)) allowTrimLayers = settings.getBoolean(allowTrimLayersID);	if (settings.hasKey(ignoreGrayLabelLayersID)) ignoreGrayLabelLayers = settings.getBoolean(ignoreGrayLabelLayersID);	if (settings.hasKey(ignoreStartsWithUnderscoreLayersID)) ignoreStartsWithUnderscoreLayers = settings.getBoolean(ignoreStartsWithUnderscoreLayersID);	if (settings.hasKey(useRootLayerID)) useRootLayer = settings.getBoolean(useRootLayerID);	if (settings.hasKey(imagesDirID)) imagesDir = settings.getString(imagesDirID);	if (settings.hasKey(projectDirID)) projectDir = settings.getString(projectDirID);	if (settings.hasKey(paddingID)) padding = settings.getDouble(paddingID);	if (settings.hasKey(resampleID)) resample = settings.getDouble(resampleID);}function saveSettings () {	var settings = new ActionDescriptor();	settings.putBoolean(writePngsID, writePngs);	settings.putBoolean(writeTemplateID, writeTemplate);	settings.putBoolean(writeJsonID, writeJson);	settings.putBoolean(ignoreHiddenLayersID, ignoreHiddenLayers);	settings.putDouble(pngScaleID, pngScale);	settings.putBoolean(groupsAsSkinsID, groupsAsSkins);	settings.putBoolean(useRulerOriginID, useRulerOrigin);	settings.putBoolean(corpToCanvasID, corpToCanvas);	settings.putBoolean(mergeGroupsID, mergeGroups);	settings.putBoolean(allowTrimLayersID, allowTrimLayers);	settings.putBoolean(ignoreGrayLabelLayersID, ignoreGrayLabelLayers);	settings.putBoolean(ignoreStartsWithUnderscoreLayersID, ignoreStartsWithUnderscoreLayers);	settings.putBoolean(useRootLayerID, useRootLayer);	settings.putString(imagesDirID, imagesDir);	settings.putString(projectDirID, projectDir);	settings.putDouble(paddingID, padding);	settings.putDouble(resampleID, resample);	app.putCustomOptions(settingsID, settings, true);}// Photoshop utility:function scaleImage (customScale) {	if (customScale == undefined) customScale = 1;	var imageSize = activeDocument.width.as("px");	activeDocument.resizeImage(UnitValue(imageSize * pngScale * customScale, "px"), null, null, resampleMethods[resampleObject]);}function rotateImage (customRotate) {	if (customRotate == undefined) customRotate = 0;	activeDocument.rotateCanvas(customRotate);}function fixRotatedOffset(rotatedCenter, originalCenter, degrees){	// Get right position of rotated layer to write JSON data	var rcx = rotatedCenter[0];	var rcy = rotatedCenter[1];	var ocx = originalCenter[0];	var ocy = originalCenter[1];	// Angle must be counter-clockwise	var theta = toRadians(degrees * -1);	// Translate point to origin	var tempX = ocx - rcx;	var tempY = ocy - rcy;	// Now apply rotation	var rotatedX = parseFloat(tempX * Math.cos(theta) - tempY * Math.sin(theta));	var rotatedY = parseFloat(tempX * Math.sin(theta) + tempY * Math.cos(theta));	// Position to JSON	var outX = ocx - rotatedX;	var outY = ocy - rotatedY;	return [outX, outY];}function checkMinimumCustomScale (layer, customScale) {	// Prevent resolution of output image too small	var boundsSize = getBoundsSize(layer);	var result = customScale;	var minPixelsOrig = Math.min(boundsSize[0], boundsSize[1]);	var minPixels = minPixelsOrig * pngScale * customScale;	if (minPixels < customScaleMin) result = Math.ceil(mathRound(customScaleMin / minPixelsOrig, 3));	return result;}var historyIndex;function storeHistory () {	historyIndex = activeDocument.historyStates.length - 1;}function restoreHistory () {	activeDocument.activeHistoryState = activeDocument.historyStates[historyIndex];}function collectLayers (layer, collect, collectOpacity, collectBlendMode) {	for (var i = 0, n = layer.layers.length; i < n; i++) {		var child = layer.layers[i];		if (ignoreHiddenLayers && !child.visible) continue;		if (ignoreGrayLabelLayers && getLayerColorByID(child.id) == "gray") {			child.visible = false;			continue;		}		if (ignoreStartsWithUnderscoreLayers && startsWith(child.name, "_")) {			child.visible = false;			continue;		}		if (child.bounds[2] == 0 && child.bounds[3] == 0) continue;		// Collect opacity		// if (child.opacity != 100 || child.fillOpacity != 100) {		if (child.opacity != 100) {			// collectOpacity[child.name] = child.opacity * child.fillOpacity * 0.01;			collectOpacity[child.name] = child.opacity * 0.01;		}		// Collect blend mode		if (child.blendMode == BlendMode.SCREEN || child.blendMode == BlendMode.LINEARDODGE || child.blendMode == BlendMode.MULTIPLY) {			switch(child.blendMode) {				case BlendMode.SCREEN:					collectBlendMode[child.name] = "screen";					break;				case BlendMode.LINEARDODGE:					collectBlendMode[child.name] = "additive";					break;				case BlendMode.MULTIPLY:					collectBlendMode[child.name] = "multiply";					break;			}		}		// Collect valid layers		if (child.layers && child.layers.length > 0) {			collectLayers(child, collect, collectOpacity, collectBlendMode);		} else if (child.kind == LayerKind.NORMAL) {			collect.push(child);			child.visible = false;		}	}}function collectGroups ( layer, collect) {	for (var i = 0; i < layer.layers.length; i++) {        var child = layer.layers[i];        if (child.visible && child.layers && child.layers.length > 0)        {        	// Current target is group        	if (isGroupAsSlot(child)) {        		// Group as slot, don't merge.				collectGroups(child, collect);        	} else if (groupsAsSkins == false) {        		// No skins, merge all groups.        		collect.push(child);        	} else if (child.parent.typename == "LayerSet") {        		// Target's parent is layerSet				collect.push(child);			} else {				collectGroups(child, collect);			}        }    }}function getVisibleSiblingLayersCount (layer, skinLayers) {	var visibleCount = 0;	for (var i = 0; i < layer.parent.layers.length; i++) {		for (var j = 0; j < skinLayers.length; j++) {			// Check layer's visibility by compares to skinLayers			if (layer.parent.layers[i] == skinLayers[j]) {				visibleCount += 1;			}		}	}	return visibleCount;}function mergeEachGroups (groups) {	for (var i = 0; i < groups.length; i++) {		var group = groups[i];		activeDocument.activeLayer = group;		group.merge();	}}function hasFilePath () {	var ref = new ActionReference();	ref.putEnumerated(charIDToTypeID("Dcmn"), charIDToTypeID("Ordn"), charIDToTypeID("Trgt"));	return executeActionGet(ref).hasKey(stringIDToTypeID("fileReference"));}function absolutePath (path) {	path = trim(path);	if (path.length == 0)		path = activeDocument.path.toString();	else if (imagesDir.indexOf("./") == 0)		path = activeDocument.path + path.substring(1);	path = path.replace(/\\/g, "/");	if (path.substring(path.length - 1) != "/") path += "/";	return path;}// Mathematics utility:function toRadians (degrees) {	return degrees * Math.PI / 180;}function mathRound(num, decimal) {	var f = decimal > 0 ? Math.pow(10, decimal) : 1;	return Math.round(num * f) / f;}// JavaScript utility:function countAssocArray (obj) {	var count = 0;	for (var key in obj)		if (obj.hasOwnProperty(key)) count++;	return count;}function trim (value) {	return value.replace(/^\s+|\s+$/g, "");}function startsWith (str, prefix) {	return str.indexOf(prefix) == 0;}function endsWith (str, suffix) {	return str.indexOf(suffix, str.length - suffix.length) !== -1;}function stripSuffix (str, suffix) {	if (endsWith(str.toLowerCase(), suffix.toLowerCase())) str = str.substring(0, str.length - suffix.length);	return str;}function layerName (layer) {	var result = stripSuffix(trim(layer.name), ".png").replace(/[:\/\\*\?\"\<\>\|]/g, "");	// Get layer name without custom parameters string (customScale, customRotate, groupAsSlot).	var endIndex = result.indexOf(" #");	if (endIndex != -1) {		result = result.substring(0, endIndex);	}	return result}function srcLayerName (layer) {	// Original version of layerName function	return stripSuffix(trim(layer.name), ".png").replace(/[:\/\\*\?\"\<\>\|]/g, "");}function isGroupAsSlot (layer) {	// Target is group with pattern, and parent is not as slot.	return (layer.name.indexOf(patternAsSlot) != -1 && layer.typename == "LayerSet" && isGroupAsSlot(layer.parent) == false) ? true : false;}function resortSlotsOrder (slots, skins) {	// Fix slots' order while groupsAsSkins enabled.	var result = {};	var resorted = [];	var exists = false;	for (var slotName in slots) {		if (resorted.length == 0) {			resorted.push(slotName);			continue;		}		// Find slot in skins.		for (var skinName in skins) {			if (exists) break;			for (var i = 0; i < skins[skinName].length; i++) {				if (slotName == skins[skinName][i]) {					// Found slot's order in skins.					var insertIndex = 0;					// Insert current slot after previous slot.					if (i > 0) {						var previousSlotName = skins[skinName][i-1];						for (var j = 0; j < resorted.length; j++) {							if (resorted[j] == previousSlotName) {								insertIndex = j + 1;								break;							}						}					}					resorted.splice(insertIndex, 0, slotName);					exists = true;					break;				}			}		}		exists = false;	}	// Copy array to dictionary	for (var i in resorted) {		result[resorted[i]] = true;	}	return result;}// Custom properties utility :function hasCustomParameters (layerName) {	var result = false;	if (layerName.search(patternRotate) != -1 || layerName.search(patternScale) != -1) {		result = true;	}	return result;}function getPropertyInfo (layerName, pattern) {	var result = NaN;	var patternIndex = layerName.lastIndexOf(pattern);	var propertyInfo;	if (patternIndex != -1) {		var patternEndIndex = patternIndex + pattern.length;		var propertyString = layerName.substring( patternEndIndex, layerName.length );		var endIndex = propertyString.indexOf(" ");		if (endIndex != -1) {			propertyInfo = propertyString.substring(0, endIndex);		} else {			propertyInfo = propertyString;		}		result = parseFloat(propertyInfo);	}	return result;}function getRotate (layerName) {	var result = 0;	var value = getPropertyInfo(layerName, patternRotate);	if (!isNaN(value)) result = value;	return result;}function getScale (layerName) {	var result = 1;	var value = getPropertyInfo(layerName, patternScale);	if (!isNaN(value)) result = value;	return result;}function getLayerColorByID( ID ) {	var ref = new ActionReference();	ref.putProperty( charIDToTypeID("Prpr") ,stringIDToTypeID('color'));	ref.putIdentifier(charIDToTypeID( "Lyr " ), ID );	return typeIDToStringID(executeActionGet(ref).getEnumerationValue(stringIDToTypeID('color')));}// Bounds and Corp to canvas utility :function clampXToCanvas(num, axis) {	return Math.min( Math.max(num, 0), docWidth );}function clampYToCanvas(num, axis) {	return Math.min( Math.max(num, 0), docHeight );}function clampBoundsToCanvas(bounds) {	var x1 = clampXToCanvas(bounds[0]);	var y1 = clampYToCanvas(bounds[1]);	var x2 = clampXToCanvas(bounds[2]);	var y2 = clampYToCanvas(bounds[3]);	return [x1, y1, x2, y2];}function getBoundsValue(layer) {	return [layer.bounds[0].value, layer.bounds[1].value, layer.bounds[2].value, layer.bounds[3].value];}function getBoundsSize(layer) {	var bounds = getBoundsValue(layer);	var width = bounds[2] - bounds[0];	var height = bounds[3] - bounds[1];	return [width, height];}function getBoundsCenter(layer) {	var bounds = getBoundsValue(layer);	var size = getBoundsSize(layer);	var x = ( bounds[0] + size[0] / 2 ) * pngScale;	var y = ( bounds[1] + size[1] / 2 ) * pngScale;	return [x, y];}function getCorpBoundsCenter(layer) {	var clampBounds = clampBoundsToCanvas(getBoundsValue(layer));	var x1 = clampBounds[0];	var y1 = clampBounds[1];	var x2 = clampBounds[2];	var y2 = clampBounds[3];	var width = x2 - x1;	var height = y2 - y1;	var x = ( x1 + width / 2 ) * pngScale;	var y = ( y1 + height / 2 ) * pngScale;	return [x, y];}function getOutOfCanvasDist(layer) {	var bounds = getBoundsValue(layer);	var x1 = bounds[0];	var y1 = bounds[1];	var x2 = activeDocument.width.as("px") - bounds[2];	var y2 = activeDocument.height.as("px") - bounds[3];	var dist = Math.min(x1, y1, x2, y2);	return dist;}function isOutOfCanvas(layer) {	if (getOutOfCanvasDist(layer) < 0) {		return true;	} else {		return false;	}}function extendCanvas(layer) {	// Extend Canvas size for not corpping visible pixels	if (!isOutOfCanvas(layer)) return;	var dist = Math.abs(getOutOfCanvasDist(layer)) * 2;	var w = activeDocument.width.as("px") + dist;	var h = activeDocument.height.as("px") + dist;	activeDocument.resizeCanvas(w, h, AnchorPosition.MIDDLECENTER);}